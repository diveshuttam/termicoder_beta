#!/usr/bin/python
# -*- coding: utf-8 -*-
# TODO use swagger based autogenerated library for implementing these functions
# TODO use colors for heading and contests
from ...models import Judge
from ...utils.logging import logger
import click
import requests
import json
from .utils import get_data, login_oauth
from beautifultable import BeautifulTable
from ...utils.Errors import AuthenticationError
from .models import Problem


class Codechef(Judge):
    def __init__(self, session_data=None):
        # Init should not have any network requests
        # do them in login, logout, check_running_contest
        logger.debug("Initializing class Codechef with session_data:\n%s"
                     % session_data)
        self.name = "Codechef"
        self.url = "https://www.codechef.com"
        self.api_url = "https://api.codechef.com"
        self.session_data = session_data
        if(session_data is not None):
            self._update_session()

    def check_login(self):
        logger.debug("Checking Login")
        if(self.session is None):
            logger.debug("No session object initialized")
            return False
        me_url = self._make_url('users/me')
        try:
            r = self._request_api(me_url)
            logger.debug(r)
            return True
        except requests.RequestException:
            return False

    def login(self):
        token = login_oauth()
        self.session_data = token
        self._update_session()
        assert(self.check_login())

    def logout(self):
        logger.warning("Logout of CodeChef.")
        click.confirm("Are you sure?", default=True, abort=True)
        self.session_data = None

    def get_running_contests(self):
        logger.debug('get running contests')
        contests = get_data.running_contests(self)
        table = BeautifulTable()
        table.width_exceed_policy = BeautifulTable.WEP_WRAP
        # TODO: use map style.headers instead of str
        # requires change with beautifultable. we may try dev version
        # TODO: sort running and upcoming
        table.column_headers = list(
            map(str, ['code', 'name', 'end', 'start']))
        for contest in contests:
            table.append_row(
                [
                    contest['code'], contest['name'],
                    str(contest['startDate']), str(contest['endDate'])
                ]
            )
        return table

    # This method serves both as a problem getter as well as kind of factory
    # for problem
    def get_problem(self, problem_name, contest_name, problem_data=None):
        # If problem data is passed, it should take precedence
        # Method should call the respective Problem.__init__ method to create a
        # problem instance and return it
        if(problem_data is not None):
            return Problem(problem_data=problem_data)
        if(problem_name is not None):
            if(contest_name is None):
                contest_name = 'PRACTICE'
            problem_url = self._make_url(
                'contests', contest_name, 'problems', problem_name)
            problem_data = self._request_api(problem_url)
            return Problem(problem_data=problem_data)


    def get_contest(self, contest_name, contest_data=None):
        # If contest data is passed, it should take precedence
        # Method should call the respective Problem.__init__ method to create a
        # problem instance and return it
        pass

    def _update_session(self):
        self.session = requests.Session()

        def debug_url(r, *args, **kwargs):
            logger.debug('Getting url %s' % r.url)

        def debug_data(r, *args, **kwargs):
            try:
                response = json.dumps(r.json(), indent=1)
            except json.JSONDecodeError:
                response = r.text
            logger.debug('Response %s' % response)

        self.session.hooks['response'].append(debug_url)
        self.session.hooks['response'].append(debug_data)
        token = self.session_data['result']['data']['access_token']
        logger.debug('Token: ' + token)
        OAuth2_Header = {
            'Authorization': 'Bearer %s' % token
        }
        self.session.headers.update(OAuth2_Header)

    def _make_url(self, *rel_urls):
        logger.debug(rel_urls)
        api_url = self.api_url.strip('/')
        join_urls = [api_url]
        for rel_url in rel_urls:
            join_urls.append(rel_url.strip('/'))
        return "/".join(join_urls)

    def _request_api(self, url):
        logger.debug('fetching url %s' % url)
        try:
            with self.session as s:
                r = s.get(url)
                logger.debug(r)
                r.raise_for_status()
            return r.json()
        except AttributeError:
            raise AuthenticationError(
                'The endpoint %s requires authorization\n'
                'Try `termicoder setup --login -j codechef` first'
                'and grant appropriate rights' % url)

    def _refresh_token(self):
        logger.debug('refreshing token')
        url = 'http://termicoder.diveshuttam.me/refresh_token/'
        raise NotImplementedError
        # TODO implement this on server side
        r = requests.get(url, data=self.session_data)
        logger.debug(r.json())
