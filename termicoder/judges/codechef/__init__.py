#!/usr/bin/python
# -*- coding: utf-8 -*-
# TODO use swagger based autogenerated library for implementing these functions
# TODO use colors for heading and contests
from ...models import Judge
from . import utils
from ...utils.logging import logger
import click
import requests
import json
from .utils import get_data
from beautifultable import BeautifulTable


class Codechef(Judge):
    def __init__(self, session_data=None):
        # Init should not have any network requests
        # do them in login, logout, check_running_contest
        logger.debug("Initializing class Codechef with session_data:\n%s"
                     % session_data)
        self.name = "Codechef"
        self.url = "https://www.codechef.com"
        self.api_url = "https://api.codechef.com"
        self.user = None
        self.session_data = session_data
        if(session_data is not None):
            self._update_session()

    def check_login(self):
        logger.debug('checking login')
        me_url = self._make_url('/users/me')
        self._request_api(me_url)

    def login(self):
        token = utils.login_client()
        self.session_data = token
        self._update_session()
        self.check_login()

    def logout(self):
        logger.warning("Logout of CodeChef.")
        click.confirm("Are you sure?", default=True, abort=True)
        self.session_data = None

    def get_running_contests(self):
        logger.debug('get running contests')
        contests = get_data.running_contests(self)
        table = BeautifulTable()
        table.width_exceed_policy = BeautifulTable.WEP_WRAP
        # TODO: use map style.headers instead of str
        # requires change with beautifultable. we may try dev version
        table.column_headers = list(
            map(str, ['code', 'name', 'endDate', 'startDate']))
        for contest in contests:
            table.append_row(
                [
                    contest['code'], contest['name'],
                    contest['startDate'], contest['endDate']
                ]
            )
        return table

    # This method serves both as a problem getter as well as kind of factory
    # for problem
    def get_problem(self, problem_name, contest_name, problem_data=None):
        # If problem data is passed, it should take precedence
        # Method should call the respective Problem.__init__ method to create a
        # problem instance and return it
        raise NotImplementedError

    def get_contest(self, contest_name, contest_data=None):
        # If contest data is passed, it should take precedence
        # Method should call the respective Problem.__init__ method to create a
        # problem instance and return it
        pass

    def _update_session(self):
        self.session = requests.Session()
        logger.debug('Token: ' + self.session_data['data']['access_token'])
        OAuth2_Header = {
            'Authorization': 'Bearer ' +
            self.session_data['data']['access_token']
        }
        self.session.headers.update(OAuth2_Header)

    def _make_url(self, rel_url):
        rel_url = rel_url.strip('/')
        api_url = self.api_url.strip('/')
        return "/".join([api_url, rel_url])

    def _request_api(self, url):
        logger.debug('Getting url %s' % url)
        r = self.session.get(url)
        logger.debug('Data got back from the request:')
        logger.debug(json.dumps(r.json(), indent=2))
        return r.json()

    def _refresh_token(self):
        logger.debug('refreshing token')
        url = 'http://termicoder.diveshuttam.me/refresh_token/'
        raise NotImplementedError
        # TODO implement this on server side
        r = requests.get(url, data=self.session_data)
        logger.debug(r.json())
